<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤ë§ˆíŠ¸ ë‹¨ì²™ CP (ì ˆëŒ€ê·œì¹™ ê°•í™”íŒ)</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f4f6f8; margin: 0; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        
        .excel-table { width: 100%; border-collapse: collapse; text-align: center; font-size: 13px; background: white; border: 2px solid #000; margin-bottom: 30px; }
        .excel-table th, .excel-table td { border: 1px solid #000; padding: 4px; vertical-align: middle; }
        .excel-table th { background-color: #ffe699; font-weight: bold; border-bottom: 2px solid #000; }
        .inner-table { width: 100%; border-collapse: collapse; border: none; }
        .inner-table td { border: none; border-bottom: 1px dashed #999; padding: 2px; }
        .inner-table tr:last-child td { border-bottom: none; }
        
        .input-cell { width: 100%; height: 100%; min-height: 24px; border: none; background: transparent; text-align: center; outline: none; font-size: 13px; }
        .input-cell:focus { background-color: #e0f2fe; }
        .spec-title { font-size: 1.25rem; font-weight: bold; color: #1e3a8a; margin-bottom: 8px; border-left: 4px solid #1e3a8a; padding-left: 10px; }
        
        .drag-handle { cursor: grab; color: #adb5bd; }
        .drag-handle:active { cursor: grabbing; color: #495057; }
        
        .excel-input-cell { width:100%; height:100%; border:none; text-align:center; outline:none; background:transparent; font-size:12px; font-family: 'Noto Sans KR', sans-serif; cursor: text; }
        .excel-input-cell:focus { background-color: #e3f2fd; font-weight:bold; box-shadow: inset 0 0 0 2px #2196f3; }
        .excel-input-cell:hover { background-color: #f8f9fa; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        const Plus = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M5 12h14"/><path d="M12 5v14"/></svg>;
        const Trash2 = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>;
        const Copy = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>;
        const Download = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>;
        const DragIcon = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>;
        const Refresh = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M23 4v6h-6"></path><path d="M1 20v-6h6"></path><path d="M3.51 9a9 9 0 0 0 20.49 15"></path></svg>;

        const getEmptyCuts = () => Array(8).fill().map(() => ({l: '', count: '', marking: ''}));
        const getEmptyRow = (t='2.10', w='100', h='100') => ({ id: Date.now() + Math.random(), t, w, h, qty: 1, cuts: getEmptyCuts() });

        function App() {
            const [viewMode, setViewMode] = useState('input');
            const [projectInfo, setProjectInfo] = useState({ company: '', siteName: '', memo: '', isNoDong: false, isBanding: true, isUnder1Ton: false });
            const [dongs, setDongs] = useState(['1ë™']);
            const [currentDong, setCurrentDong] = useState('1ë™');

            const defaultDongData = { 
                inputMode: 'sales', gridData: [], colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' }, 
                parsedItems: [], availableSpecs: [], selectedSpecs: [], manualRows: {}, currentManualSpec: '', cpResult: null 
            };
            const [dongDataStore, setDongDataStore] = useState({ '1ë™': JSON.parse(JSON.stringify(defaultDongData)) });
            const currentData = dongDataStore[currentDong] || defaultDongData;
            
            const updateCurrentData = (updates) => {
                setDongDataStore(prev => ({ ...prev, [currentDong]: { ...prev[currentDong], ...updates } }));
            };

            const addDong = () => {
                const name = prompt("ìƒˆ ë™ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 2ë™):");
                if (name && !dongs.includes(name)) {
                    setDongs([...dongs, name]);
                    setDongDataStore(prev => ({ ...prev, [name]: JSON.parse(JSON.stringify(defaultDongData)) }));
                    setCurrentDong(name);
                }
            };
            const deleteDong = (name) => {
                if(dongs.length <= 1) return alert("ìµœì†Œ 1ê°œì˜ ë™ì€ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.");
                if(confirm(`'${name}'ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                    setDongs(dongs.filter(d => d !== name));
                    if(currentDong === name) setCurrentDong(dongs[0]);
                    setDongDataStore(prev => { const n = {...prev}; delete n[name]; return n; });
                }
            };

            const handlePaste = (e) => {
                e.preventDefault();
                const text = e.clipboardData.getData('text');
                const rows = text.trim().split('\n').map(row => row.split('\t'));
                updateCurrentData({ gridData: rows });
            };

            const handleGridEdit = (rIdx, cIdx, val) => {
                const newGrid = [...currentData.gridData];
                newGrid[rIdx][cIdx] = val; 
                updateCurrentData({ gridData: newGrid });
            };

            const resetExcel = () => {
                updateCurrentData({ gridData: [], parsedItems: [], availableSpecs: [], selectedSpecs: [] });
            };

            const extractData = () => {
                let items = [];
                let specSet = new Set();
                const { gridData, colMapping } = currentData;
                
                const getIdx = (key) => Object.keys(colMapping).find(k => colMapping[k] === key);
                const tIdx = getIdx('thickness'); const wIdx = getIdx('width'); const hIdx = getIdx('height');
                const lenIdx = getIdx('length'); const qtyIdx = getIdx('qty'); const markIdx = getIdx('marking');

                if (!lenIdx || !qtyIdx) return alert('ê¸¸ì´ì™€ ìˆ˜ëŸ‰ ì—´ì„ ì§€ì •í•´ì£¼ì„¸ìš”.');

                gridData.forEach(row => {
                    let rawLen = parseFloat(String(row[lenIdx]||'').replace(/,/g, '').trim());
                    let qty = parseInt(String(row[qtyIdx]||'').replace(/,/g, '').replace(/[^0-9]/g, '').trim());
                    let lengthInMm = (rawLen > 0 && rawLen < 20) ? Math.round(rawLen * 1000) : Math.round(rawLen);

                    if (lengthInMm > 0 && lengthInMm < 2000 && qty > 0) {
                        let thick = parseFloat(String(row[tIdx]||'2.1').replace(/[^0-9.]/g, ''));
                        let formattedThick = Number.isInteger(thick) ? thick.toFixed(1) : thick.toString();
                        if (formattedThick === '2.10') formattedThick = '2.1';
                        
                        let width = parseInt(String(row[wIdx]||'100').replace(/[^0-9]/g, ''));
                        let height = parseInt(String(row[hIdx]||'100').replace(/[^0-9]/g, ''));
                        let marking = String(row[markIdx]||'').trim();
                        let specKey = `${width}*${height} ${formattedThick}T`;

                        specSet.add(specKey);
                        let existing = items.find(i => i.specKey === specKey && i.length === lengthInMm && i.marking === marking);
                        if (existing) existing.qty += qty;
                        else items.push({ specKey, thick, width, height, length: lengthInMm, qty, marking });
                    }
                });

                if (items.length === 0) return alert('2000 ë¯¸ë§Œì˜ ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                
                let specs = Array.from(specSet).sort();
                updateCurrentData({ parsedItems: items, availableSpecs: specs, selectedSpecs: specs });
                alert(`ì„±ê³µ! ì´ ${items.reduce((acc, cur) => acc + cur.qty, 0)}ê°œì˜ ë‹¨ì²™ ì¡°ê°ì„ ì¶”ì¶œí–ˆìŠµë‹ˆë‹¤.`);
            };

            const toggleSpec = (specKey) => {
                let newSelected = [...currentData.selectedSpecs];
                if (newSelected.includes(specKey)) newSelected = newSelected.filter(s => s !== specKey);
                else newSelected.push(specKey);
                updateCurrentData({ selectedSpecs: newSelected });
            };

            const [isCalculating, setIsCalculating] = useState(false);
            const [calcMessage, setCalcMessage] = useState("");

            // ğŸ’¡ [ì´ˆê°•ë ¥ ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì • ì™„ë£Œ] 
            // 1. ë‹¨ì²™ ê¸¸ì´ëŠ” ë¬´ì¡°ê±´ ì§§ì€ ê¸¸ì´ë¶€í„° ì‚¬ìš© (ì˜¤ë¦„ì°¨ìˆœ)
            // 2. í•©ê³„ ê¸¸ì´ëŠ” ë¬´ì¡°ê±´ ì˜¤ë¦„ì°¨ìˆœ (ì‚¬ì‹¤ìƒ ë‚´ë¦¼ì°¨ìˆœ: 1ë²ˆ > 2ë²ˆ > 3ë²ˆ)
            // 3. í•©ê³„ 2000 ì´ìƒ 5850 ë¯¸ë§Œ
            // 4. 8ì»· ë¯¸ë§Œ (ì¡°ê° ìˆ˜ 8ê°œ ì´í•˜ í—ˆìš© - 7ì»·)
            const runSimulationCore = (itemsToPack) => {
                let groups = {};
                itemsToPack.forEach(item => {
                    if(!groups[item.specKey]) groups[item.specKey] = [];
                    groups[item.specKey].push({ ...item });
                });

                let resultsBySpec = {};

                for(let specKey in groups) {
                    let poolMaster = [];
                    let idCounter = 0;
                    groups[specKey].forEach(p => { 
                        for(let i=0; i<p.qty; i++) poolMaster.push({ ...p, localId: idCounter++ }); 
                    });

                    // [ì¡°ê±´ 1] ë‹¨ì²™ì˜ ê¸¸ì´ëŠ” ë¬´ì¡°ê±´ ì§§ì€ ê¸¸ì´ë¶€í„° ì‚¬ìš© (ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬)
                    poolMaster.sort((a, b) => a.length - b.length || a.marking.localeCompare(b.marking));

                    let bestGlobalPlan = [];
                    let avail = [...poolMaster];
                    // [ì¡°ê±´ 2] í•©ê³„ ê¸¸ì´ëŠ” ì ì  ì¤„ì–´ë“¤ì–´ì•¼ í•¨. ì²« ì‹œì‘ MaxëŠ” 5850(ë¯¸ë§Œ).
                    let previousSum = 5850; 

                    while (avail.length > 0) {
                        let currentBin = { sum: 0, pieces: [] };
                        let usedIds = new Set();
                        
                        // [ì¡°ê±´ 2 êµ¬í˜„] ì´ì „ ìˆœë²ˆ í•©ê³„ë³´ë‹¤ ë¬´ì¡°ê±´ ì‘ì•„ì•¼ í•¨ (í•©ê³„ ë‚´ë¦¼ì°¨ìˆœ)
                        // ë‹¨, 5850 ë¯¸ë§Œì´ì–´ì•¼ í•˜ë¯€ë¡œ 5849ê°€ ìµœëŒ€ ì‹œì‘ì 
                        let targetMax = previousSum - 1; 
                        if (targetMax >= 5850) targetMax = 5849;
                        
                        // ë” ì´ìƒ í•©ê³„ë¥¼ ì¤„ì¼ ìˆ˜ ì—†ê±°ë‚˜ 2000 ë¯¸ë§Œì´ ê°•ì œë˜ëŠ” ê²½ìš° ì¤‘ë‹¨
                        if (targetMax < 2000) break; 

                        // Greedy: ì•ì—ì„œë¶€í„°(ì§§ì€ ê²ƒë¶€í„°) ë„£ê¸°
                        for (let i = 0; i < avail.length; i++) {
                            // [ì¡°ê±´ 4] ì»·íŒ… ìˆ˜ í•©ê³„ 8ì»· ë¯¸ë§Œ -> ì¡°ê° ìˆ˜ 8ê°œê¹Œì§€ í—ˆìš© (7ë²ˆ ì»·íŒ… = 8ì¡°ê°)
                            // 8ì»· "ë¯¸ë§Œ"ì´ë¯€ë¡œ 7ì»·ê¹Œì§€ ê°€ëŠ¥ -> 8ì¡°ê°
                            if (currentBin.pieces.length >= 8) break; 
                            
                            let piece = avail[i];
                            if (currentBin.sum + piece.length <= targetMax) {
                                currentBin.pieces.push(piece);
                                currentBin.sum += piece.length;
                                usedIds.add(piece.localId);
                            }
                        }

                        // [ì¡°ê±´ 3] í•©ê³„ 2000 ì´ìƒ ê°•ì œ ë‹¬ì„± (Swap ë¡œì§)
                        // ì§§ì€ ê²ƒë§Œ ë„£ì–´ì„œ 2000ì´ ì•ˆ ë˜ë©´, ë„£ì€ ê²ƒ ì¤‘ í•˜ë‚˜ë¥¼ ë¹¼ê³  ì•ˆ ë„£ì€ ê²ƒ ì¤‘ ê¸´ ê±¸ë¡œ êµì²´
                        if (currentBin.sum < 2000) {
                            let swapped = true;
                            // ë¯¸ì‚¬ìš© ìì¬ ëª©ë¡ (í° ê²ƒë¶€í„° ì •ë ¬)
                            let unused = avail.filter(p => !usedIds.has(p.localId));
                            unused.sort((a, b) => b.length - a.length);

                            while (currentBin.sum < 2000 && swapped && unused.length > 0) {
                                swapped = false;
                                // í˜„ì¬ ë°”êµ¬ë‹ˆì˜ ì¡°ê°ë“¤ì„ ìˆœíšŒí•˜ë©° êµì²´ ì‹œë„
                                for (let c = 0; c < currentBin.pieces.length; c++) {
                                    let c_piece = currentBin.pieces[c];
                                    
                                    for (let r = 0; r < unused.length; r++) {
                                        let r_piece = unused[r];
                                        let diff = r_piece.length - c_piece.length;
                                        let newSum = currentBin.sum + diff;
                                        
                                        // êµì²´ ì‹œ í•©ê³„ê°€ ëŠ˜ì–´ë‚˜ê³ , ìƒí•œì„ ì„ ë„˜ì§€ ì•ŠëŠ”ë‹¤ë©´ êµì²´
                                        if (diff > 0 && newSum <= targetMax) {
                                            // êµì²´ ìˆ˜í–‰
                                            usedIds.delete(c_piece.localId);
                                            usedIds.add(r_piece.localId);
                                            
                                            currentBin.pieces[c] = r_piece;
                                            currentBin.sum = newSum;
                                            
                                            // ëª©ë¡ ê°±ì‹ 
                                            unused.splice(r, 1); // ì‚¬ìš©í•œ ê²ƒ ì œê±°
                                            // ëº€ ê²ƒì€ ë‹¤ì‹œ unusedë¡œ (êµ³ì´ ì•ˆ ë„£ì–´ë„ ë¨, ì´ë²ˆ ë£¨í”„ì—ì„  ì œì™¸)
                                            
                                            swapped = true;
                                            break;
                                        }
                                    }
                                    if (swapped) break;
                                }
                            }
                        }

                        // ìœ íš¨ì„± ìµœì¢… ê²€ì‚¬ (2000 ~ targetMax)
                        if (currentBin.sum >= 2000 && currentBin.sum <= targetMax && currentBin.pieces.length > 0) {
                             // [ì¡°ê±´ 1 ìœ ì§€] ë‚´ë¶€ ì¡°ê°ì€ ì§§ì€ ìˆœì„œë¡œ ì •ë ¬ (ì˜¤ë¦„ì°¨ìˆœ)
                            currentBin.pieces.sort((a, b) => a.length - b.length || a.marking.localeCompare(b.marking));
                            
                            bestGlobalPlan.push(currentBin);
                            avail = avail.filter(p => !usedIds.has(p.localId));
                            previousSum = currentBin.sum; // ë‹¤ìŒ ìˆœë²ˆì€ í˜„ì¬ í•©ê³„ë³´ë‹¤ ì‘ì•„ì•¼ í•¨
                        } else {
                            // ë” ì´ìƒ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì¡°í•©ì„ ë§Œë“¤ ìˆ˜ ì—†ìŒ
                            break;
                        }
                    }

                    // ìµœì¢… ì¶œë ¥ ì–‘ì‹ìœ¼ë¡œ ë³€í™˜
                    let formattedPatterns = [];
                    bestGlobalPlan.forEach(bin => {
                        let cutsObj = {};
                        bin.pieces.forEach(p => {
                            let k = `${p.length}_${p.marking}`;
                            if(!cutsObj[k]) cutsObj[k] = { length: p.length, marking: p.marking, cutCount: 0 };
                            cutsObj[k].cutCount++;
                        });
                        
                        let pieceArray = Object.values(cutsObj);
                        // [ì¡°ê±´ 1] í‘œì‹œ ìˆœì„œë„ ì§§ì€ ê²ƒ ë¶€í„°
                        pieceArray.sort((a,b) => a.length - b.length);
                        
                        let signature = pieceArray.map(p => `${p.length}-${p.cutCount}-${p.marking}`).join('|') + `_${bin.sum}`;
                        let existing = formattedPatterns.find(fp => fp.signature === signature);
                        
                        if (existing) existing.count++;
                        else {
                            formattedPatterns.push({
                                signature: signature, thick: bin.pieces[0].thick, width: bin.pieces[0].width, height: bin.pieces[0].height,
                                totalLength: bin.sum, count: 1, groups: pieceArray
                            });
                        }
                    });

                    // [ì¡°ê±´ 2 í™•ì¸] ê²°ê³¼ ëª©ë¡ë„ í•©ê³„ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
                    formattedPatterns.sort((a,b) => b.totalLength - a.totalLength);
                    
                    resultsBySpec[specKey] = formattedPatterns;
                }
                return resultsBySpec;
            };

            const calculateAutoCP = () => {
                if (currentData.selectedSpecs.length === 0) return alert("ê³„ì‚°í•  ê·œê²©ì„ ì„ íƒí•´ì£¼ì„¸ìš”.");
                setCalcMessage("4ëŒ€ ì ˆëŒ€ ê·œì¹™ì„ 100% ì¶©ì¡±ì‹œí‚¤ëŠ” ë¬´ê²°ì  CPë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤...");
                setIsCalculating(true);
                
                setTimeout(() => {
                    const itemsToPack = currentData.parsedItems.filter(item => currentData.selectedSpecs.includes(item.specKey));
                    const resultsBySpec = runSimulationCore(itemsToPack);
                    updateCurrentData({ cpResult: resultsBySpec });
                    setIsCalculating(false);
                    setViewMode('result');
                }, 100);
            };

            const calculateAllAutoCP = () => {
                const hasData = dongs.some(d => dongDataStore[d].parsedItems.length > 0 && dongDataStore[d].selectedSpecs.length > 0);
                if (!hasData) return alert("ê³„ì‚°í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");

                setCalcMessage("ì „ì²´ ë™ ë°ì´í„°ë¥¼ ë¬´ê²°ì  ì›ì¹™ìœ¼ë¡œ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...");
                setIsCalculating(true);

                setTimeout(() => {
                    let storeUpdates = { ...dongDataStore };
                    let processedCount = 0;

                    for (let dongName of dongs) {
                        const dData = storeUpdates[dongName];
                        if (dData.parsedItems.length > 0 && dData.selectedSpecs.length > 0) {
                            const itemsToPack = dData.parsedItems.filter(item => dData.selectedSpecs.includes(item.specKey));
                            if (itemsToPack.length > 0) {
                                const resultsBySpec = runSimulationCore(itemsToPack);
                                dData.cpResult = resultsBySpec;
                                processedCount++;
                            }
                        }
                    }

                    setDongDataStore(storeUpdates);
                    setIsCalculating(false);
                    setViewMode('result');
                    alert(`ì´ ${processedCount}ê°œ ë™ì˜ ê³„ì‚°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
                }, 100);
            };

            const copyToManual = () => {
                if(!currentData.cpResult) return;
                let newManualRows = {};
                let firstSpec = null;
                Object.keys(currentData.cpResult).sort().forEach((specKey, i) => {
                    if (i === 0) firstSpec = specKey;
                    newManualRows[specKey] = [];
                    currentData.cpResult[specKey].forEach(pattern => {
                        let cuts = getEmptyCuts();
                        pattern.groups.sort((a,b) => a.length - b.length);
                        pattern.groups.forEach((g, idx) => { if(idx < 8) cuts[idx] = { l: g.length, count: g.cutCount, marking: g.marking }; });
                        newManualRows[specKey].push({ id: Date.now() + Math.random(), t: pattern.thick.toString(), w: pattern.width, h: pattern.height, qty: pattern.count, cuts: cuts });
                    });
                });
                updateCurrentData({ manualRows: newManualRows, currentManualSpec: firstSpec });
                setViewMode('manual');
                alert('ìˆ˜ë™ í¸ì§‘ê¸°ë¡œ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
            };

            const startBlankManual = () => {
                let spec = prompt("ê·œê²© ì…ë ¥ (ì˜ˆ: 100*100 2.1T)", "100*100 2.1T");
                if(!spec) return;
                updateCurrentData({ manualRows: { [spec]: [getEmptyRow()] }, currentManualSpec: spec });
                setViewMode('manual');
            };

            const convertManualToResult = () => {
                let resultsBySpec = {};
                Object.keys(currentData.manualRows).forEach(specKey => {
                    let rows = currentData.manualRows[specKey];
                    if(!resultsBySpec[specKey]) resultsBySpec[specKey] = [];
                    
                    rows.forEach(row => {
                        let validCuts = row.cuts.filter(c => c.l && c.count);
                        if(validCuts.length === 0) return;
                        
                        let totalLength = validCuts.reduce((sum, c) => sum + (parseFloat(c.l) * parseInt(c.count)), 0);
                        validCuts.sort((a,b) => parseFloat(a.l) - parseFloat(b.l));
                        
                        resultsBySpec[specKey].push({
                            thick: parseFloat(row.t), width: parseInt(row.w), height: parseInt(row.h),
                            count: parseInt(row.qty), totalLength: totalLength,
                            groups: validCuts.map(c => ({ length: parseFloat(c.l), cutCount: parseInt(c.count), marking: c.marking || '' }))
                        });
                    });
                });
                
                // ìˆ˜ë™ ëª¨ë“œ ê²°ê³¼ë„ ë¬´ì¡°ê±´ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬ ë½
                Object.values(resultsBySpec).forEach(patterns => patterns.sort((a,b) => b.totalLength - a.totalLength));
                updateCurrentData({ cpResult: resultsBySpec });
                setViewMode('result');
            };

            const dragItem = useRef(); const dragOverItem = useRef();
            const handleDragStart = (e, index) => { dragItem.current = index; e.dataTransfer.effectAllowed = "move"; };
            const handleDragEnter = (e, index) => { dragOverItem.current = index; };
            const handleDragEnd = () => {
                if(dragItem.current === null || dragOverItem.current === null) return;
                const spec = currentData.currentManualSpec;
                const newRows = [...currentData.manualRows[spec]];
                const item = newRows.splice(dragItem.current, 1)[0];
                newRows.splice(dragOverItem.current, 0, item);
                dragItem.current = null; dragOverItem.current = null;
                updateCurrentData({ manualRows: { ...currentData.manualRows, [spec]: newRows } });
            };

            const remainingSummary = useMemo(() => {
                const summary = {};
                currentData.parsedItems.forEach(item => {
                    const key = `${item.specKey}|${item.length}|${item.marking}`;
                    if (!summary[key]) summary[key] = { ...item, required: 0, used: 0 };
                    summary[key].required += item.qty;
                });
                const status = Object.values(summary);
                Object.values(currentData.manualRows).forEach(rows => {
                    rows.forEach(row => {
                        row.cuts.forEach(cut => {
                            if (cut.l && cut.count) {
                                const cutLen = parseFloat(cut.l);
                                const totalQty = parseInt(cut.count) * parseInt(row.qty || 1);
                                const spec = `${row.w}*${row.h} ${parseFloat(row.t).toFixed(2)}T`;
                                const match = status.find(item => item.length === cutLen && item.marking === (cut.marking || '') && item.specKey === spec);
                                if (match) match.used += totalQty;
                            }
                        });
                    });
                });
                return status.sort((a, b) => a.length - b.length);
            }, [currentData.parsedItems, currentData.manualRows]);

            const downloadExcel = async () => {
                if (!currentData.cpResult) return alert("ì €ì¥í•  CP ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
                try {
                    const borderStyle = { top: {style:'thin'}, left: {style:'thin'}, bottom: {style:'thin'}, right: {style:'thin'} };
                    const alignCenter = { vertical: 'middle', horizontal: 'center' };
                    const headerFill = { type: 'pattern', pattern:'solid', fgColor:{argb:'FFFFE699'} };
                    const totalFill = { type: 'pattern', pattern:'solid', fgColor:{argb:'FFFFFFCC'} };

                    for (let specKey of Object.keys(currentData.cpResult).sort()) {
                        const patterns = currentData.cpResult[specKey];
                        if (patterns.length === 0) continue;
                        const workbook = new ExcelJS.Workbook();
                        const sheet = workbook.addWorksheet('CP', { pageSetup: { paperSize: 9, orientation: 'landscape', fitToPage: true, fitToWidth: 1, fitToHeight: 0 } });

                        let comp = projectInfo.company || 'ì—…ì²´ëª…'; let site = projectInfo.siteName || 'í˜„ì¥ëª…';
                        const isDefault = specKey.includes('100*100') && specKey.includes('2.1');
                        let title = `${comp}(${site})`;
                        if (!projectInfo.isNoDong) title += ` - ${currentDong}`;
                        if (!isDefault) title += ` [${specKey}]`;

                        sheet.mergeCells('A1:N1');
                        const titleCell = sheet.getCell('A1'); titleCell.value = title;
                        titleCell.font = { name: 'Malgun Gothic', size: 16, bold: true };

                        let warnings = [];
                        if (projectInfo.isBanding) warnings.push("ì¹ ë°´ë”©ì— ë™í‘œì‹œ í•´ì£¼ì„¸ìš”");
                        if (projectInfo.isUnder1Ton) warnings.push("1í†¤ ë¯¸ë§Œ ë°´ë”©");
                        if (projectInfo.memo) warnings.push(projectInfo.memo);
                        if (warnings.length > 0) {
                            sheet.mergeCells('A3:G3');
                            const warnCell = sheet.getCell('A3'); warnCell.value = warnings.join(", ");
                            warnCell.font = { name: 'Malgun Gothic', size: 12, bold: true, color: { argb: 'FFFF0000' } };
                        }

                        const headers = ["ìˆœë²ˆ", "ë‘ê»˜", "ì¥ë³€", "ë‹¨ë³€", "ì„ íƒ€ê³µê¸¸ì´", "ìˆ˜ëŸ‰", "ë‹¨ì²™ê¸¸ì´", "ì»·íŒ… ìˆ˜", "ìˆ˜ëŸ‰", "ë§ˆí‚¹", "í•©ê³„", "ë¡œìŠ¤", "ì»·íŒ…ë‚ ", "ë¹„ê³ "];
                        const headerRow = sheet.getRow(4); headerRow.values = headers; headerRow.height = 30;
                        headerRow.eachCell((cell) => { cell.fill = headerFill; cell.font = { name: 'Malgun Gothic', size: 11, bold: true }; cell.alignment = alignCenter; cell.border = borderStyle; });

                        let currentRow = 5; let totalRaw = 0; let totalCut = 0;
                        
                        // ì—‘ì…€ ì €ì¥ ì‹œì—ë„ ë¬´ì¡°ê±´ í•©ê³„ ë‚´ë¦¼ì°¨ìˆœ ë³´ì¥
                        patterns.sort((a,b) => b.totalLength - a.totalLength);

                        patterns.forEach((pattern, index) => {
                            const rowsInBatch = pattern.groups.length;
                            const totalUsed = pattern.totalLength;
                            const cuts = pattern.groups.reduce((s, it) => s + it.cutCount, 0);
                            const bladeLoss = Math.round(cuts * 2.6);
                            totalRaw += pattern.count; totalCut += (cuts * pattern.count);
                            const startRow = currentRow;

                            // ë‚´ë¶€ ë‹¨ì²™ ì˜¤ë¦„ì°¨ìˆœ ìœ ì§€ ë³´ì¥
                            pattern.groups.sort((a,b) => a.length - b.length);

                            pattern.groups.forEach((group, idx) => {
                                const row = sheet.getRow(currentRow); row.height = 25;
                                row.getCell(7).value = group.length; row.getCell(8).value = group.cutCount;
                                row.getCell(9).value = group.cutCount * pattern.count; row.getCell(10).value = group.marking;
                                row.getCell(10).alignment = { vertical: 'middle', horizontal: 'left', indent: 1 };

                                if (idx === 0) {
                                    row.getCell(1).value = index + 1; row.getCell(2).value = pattern.thick;
                                    row.getCell(3).value = pattern.width; row.getCell(4).value = pattern.height;
                                    row.getCell(6).value = pattern.count; row.getCell(11).value = totalUsed;
                                    row.getCell(12).value = { formula: `E${currentRow}-K${currentRow}`, result: -totalUsed };
                                    row.getCell(13).value = bladeLoss;
                                }
                                for(let c=1; c<=14; c++) { const cell = row.getCell(c); cell.border = borderStyle; if(c!==10) cell.alignment = alignCenter; cell.font = { name: 'Malgun Gothic', size: 11 }; }
                                currentRow++;
                            });
                            if (rowsInBatch > 1) { const endRow = currentRow - 1; ['A','B','C','D','E','F','K','L','M','N'].forEach(col => { sheet.mergeCells(`${col}${startRow}:${col}${endRow}`); }); }
                        });

                        const totalRow = sheet.getRow(currentRow); totalRow.height = 30;
                        sheet.mergeCells(`A${currentRow}:E${currentRow}`); sheet.getCell(`A${currentRow}`).value = "í•© ê³„";
                        sheet.getCell(`F${currentRow}`).value = totalRaw;
                        sheet.mergeCells(`G${currentRow}:H${currentRow}`); sheet.getCell(`G${currentRow}`).value = "í•© ê³„";
                        sheet.getCell(`I${currentRow}`).value = totalCut;
                        for(let c=1; c<=14; c++) { const cell = totalRow.getCell(c); cell.fill = totalFill; cell.border = borderStyle; cell.alignment = alignCenter; cell.font = { name: 'Malgun Gothic', size: 11, bold: true }; }
                        sheet.columns = [ { width: 8 }, { width: 8 }, { width: 8 }, { width: 8 }, { width: 12 }, { width: 8 }, { width: 12 }, { width: 8 }, { width: 8 }, { width: 15 }, { width: 12 }, { width: 12 }, { width: 8 }, { width: 15 } ];

                        const buffer = await workbook.xlsx.writeBuffer();
                        let filename = `${comp}(${site})`;
                        if (!projectInfo.isNoDong) filename += `_${currentDong}`;
                        if (!isDefault) filename += `_${specKey}`;
                        filename += `.xlsx`;
                        saveAs(new Blob([buffer]), filename);
                    }
                } catch(e) { alert("ì—‘ì…€ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: " + e.message); }
            };

            return (
                <div className="flex h-screen overflow-hidden text-gray-800">
                    <div className="w-[280px] bg-white border-r border-gray-200 flex flex-col z-10 shadow">
                        <div className="p-6 border-b bg-blue-900 text-white">
                            <h1 className="text-xl font-bold flex items-center gap-2">ğŸ› ï¸ Smart CP</h1>
                            <p className="text-xs opacity-80 mt-1">4ëŒ€ ì ˆëŒ€ ê·œì¹™ 100% ë³´ì¥ ì—”ì§„</p>
                        </div>
                        <div className="p-4 flex-1 overflow-auto">
                            <div className="space-y-3 mb-6">
                                <label className="text-xs font-bold text-gray-500">í”„ë¡œì íŠ¸ ì •ë³´</label>
                                <input className="w-full p-2 border rounded text-sm bg-gray-50 outline-none focus:ring-2 focus:ring-blue-500" placeholder="ì—…ì²´ëª… (ì˜ˆ: ì˜¤ì„œì—ë„ˆì§€)" value={projectInfo.company} onChange={e => setProjectInfo({...projectInfo, company: e.target.value})} />
                                <input className="w-full p-2 border rounded text-sm bg-gray-50 outline-none focus:ring-2 focus:ring-blue-500" placeholder="í˜„ì¥ëª… (ì˜ˆ: ê¹€ì²œê³µì¥)" value={projectInfo.siteName} onChange={e => setProjectInfo({...projectInfo, siteName: e.target.value})} />
                                <input className="w-full p-2 border rounded text-sm bg-gray-50 outline-none focus:ring-2 focus:ring-blue-500" placeholder="ê¸°íƒ€ì‚¬í•­ (ë©”ëª¨)" value={projectInfo.memo} onChange={e => setProjectInfo({...projectInfo, memo: e.target.value})} />
                                <div className="flex flex-col gap-1 mt-2">
                                    <label className="flex items-center gap-2 text-xs cursor-pointer font-bold text-blue-700">
                                        <input type="checkbox" checked={projectInfo.isNoDong} onChange={e => setProjectInfo({...projectInfo, isNoDong: e.target.checked})} /> ë™ êµ¬ë¶„ ì—†ìŒ
                                    </label>
                                    <label className="flex items-center gap-2 text-xs cursor-pointer">
                                        <input type="checkbox" checked={projectInfo.isBanding} onChange={e => setProjectInfo({...projectInfo, isBanding: e.target.checked})} /> ì² ë°´ë”© ë™í‘œê¸°
                                    </label>
                                    <label className="flex items-center gap-2 text-xs cursor-pointer">
                                        <input type="checkbox" checked={projectInfo.isUnder1Ton} onChange={e => setProjectInfo({...projectInfo, isUnder1Ton: e.target.checked})} /> 1í†¤ ë¯¸ë§Œ ë°´ë”©
                                    </label>
                                </div>
                            </div>
                            <div className="space-y-2 border-t pt-4">
                                <button onClick={() => setViewMode('input')} className={`w-full text-left px-4 py-3 rounded-lg font-bold text-sm ${viewMode === 'input' ? 'bg-blue-50 text-blue-800 border border-blue-200' : 'text-gray-600 hover:bg-gray-100'}`}>1. ë°ì´í„° ì…ë ¥</button>
                                <button onClick={() => setViewMode('manual')} className={`w-full text-left px-4 py-3 rounded-lg font-bold text-sm ${viewMode === 'manual' ? 'bg-blue-50 text-blue-800 border border-blue-200' : 'text-gray-600 hover:bg-gray-100'}`}>2. ì§ì ‘ ì‘ì„± / ìˆ˜ì •</button>
                                <button onClick={() => setViewMode('result')} className={`w-full text-left px-4 py-3 rounded-lg font-bold text-sm ${viewMode === 'result' ? 'bg-blue-50 text-blue-800 border border-blue-200' : 'text-gray-600 hover:bg-gray-100'}`}>3. ê²°ê³¼ í™•ì¸ (CPí‘œ)</button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 flex flex-col relative overflow-hidden bg-gray-50">
                        {isCalculating && (
                            <div className="absolute inset-0 bg-white/90 z-50 flex flex-col items-center justify-center">
                                <div className="animate-spin rounded-full h-12 w-12 border-b-4 border-blue-800 mb-4"></div>
                                <p className="text-blue-800 font-bold text-lg">{calcMessage}</p>
                            </div>
                        )}

                        {!projectInfo.isNoDong && (
                            <div className="bg-white border-b border-gray-200 px-6 pt-3 flex gap-2 overflow-x-auto">
                                {dongs.map(dong => (
                                    <div key={dong} className="relative group">
                                        <button onClick={() => setCurrentDong(dong)} className={`px-4 py-2 rounded-t-lg font-bold text-sm border-t border-x ${currentDong === dong ? 'bg-white border-gray-200 text-blue-800 pb-3' : 'bg-gray-100 border-transparent text-gray-500 hover:bg-gray-200'} transition-all`}>
                                            {dong}
                                        </button>
                                        <button onClick={(e) => { e.stopPropagation(); deleteDong(dong); }} className={`absolute right-1 top-2 p-1 text-gray-400 hover:text-red-500 ${currentDong === dong ? 'opacity-100' : 'opacity-0 group-hover:opacity-100'}`}><Trash2 /></button>
                                    </div>
                                ))}
                                <button onClick={addDong} className="px-3 py-2 text-gray-500 hover:text-blue-800 font-bold"><Plus /></button>
                            </div>
                        )}

                        {viewMode === 'input' && (
                            <div className="p-6 h-full flex flex-col overflow-auto custom-scrollbar">
                                <div className="bg-white p-4 rounded-xl shadow-sm border border-gray-200 flex justify-between items-center mb-4">
                                    <div className="flex gap-2">
                                        <button onClick={() => updateCurrentData({ inputMode: 'sales', colMapping: { 1: 'width', 2: 'height', 3: 'thickness', 4: 'length', 8: 'qty', 13: 'marking' } })} className={`px-4 py-2 text-sm font-bold rounded ${currentData.inputMode === 'sales' ? 'bg-blue-800 text-white shadow' : 'bg-gray-100 text-gray-600'}`}>ì˜ì—… ì–‘ì‹</button>
                                        <button onClick={() => updateCurrentData({ inputMode: 'design', colMapping: { 2: 'width', 3: 'height', 4: 'thickness', 5: 'length', 7: 'qty', 8: 'marking' } })} className={`px-4 py-2 text-sm font-bold rounded ${currentData.inputMode === 'design' ? 'bg-blue-800 text-white shadow' : 'bg-gray-100 text-gray-600'}`}>ì„¤ê³„ ì–‘ì‹</button>
                                    </div>
                                    <div className="flex gap-2 items-center">
                                        <button onClick={startBlankManual} className="px-4 py-2 border-2 border-dashed border-indigo-400 text-indigo-700 bg-indigo-50 text-sm font-bold rounded hover:bg-indigo-100">âœ¨ ì²˜ìŒë¶€í„° ì§ì ‘ ì§œê¸°</button>
                                        <div className="w-px h-6 bg-gray-300 mx-2"></div>
                                        <button onClick={extractData} className="px-4 py-2 bg-gray-700 text-white text-sm font-bold rounded hover:bg-gray-800">1ë‹¨ê³„: í˜„ì¬ ë™ ë°ì´í„° ì½ê¸°</button>
                                        <button onClick={calculateAutoCP} disabled={currentData.selectedSpecs.length===0} className={`px-4 py-2 text-sm font-bold rounded text-white ${currentData.selectedSpecs.length>0 ? 'bg-blue-500 hover:bg-blue-600 shadow' : 'bg-gray-400 cursor-not-allowed'}`}>2ë‹¨ê³„: í˜„ì¬ ë™ ê³„ì‚°</button>
                                        <button onClick={calculateAllAutoCP} className="px-4 py-2 text-sm font-bold rounded text-white bg-blue-800 hover:bg-blue-900 shadow flex items-center gap-2"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg> ì „ì²´ ë™ í•œ ë²ˆì— ê³„ì‚°</button>
                                    </div>
                                </div>
                                <div className="flex-1 flex gap-4 overflow-hidden">
                                    <div className="flex-[3] bg-white rounded-xl shadow-sm border border-gray-200 flex flex-col relative overflow-hidden">
                                        <div className="p-2 border-b bg-gray-50 flex justify-end">
                                            <button onClick={resetExcel} className="flex items-center gap-1 text-xs font-bold text-red-500 hover:bg-red-50 px-2 py-1 rounded"><Refresh /> ì´ˆê¸°í™” (ë‹¤ì‹œ ë¶™ì—¬ë„£ê¸°)</button>
                                        </div>
                                        {currentData.gridData.length === 0 ? (
                                            <div className="absolute inset-0 flex items-center justify-center bg-gray-50"><textarea className="absolute inset-0 opacity-0 cursor-text" onPaste={handlePaste} autoFocus /><div className="text-center text-gray-400 pointer-events-none"><p className="text-4xl font-bold mb-3">ğŸ“‹ Ctrl + V</p><p>ì—‘ì…€ ê²¬ì ì„œ í‘œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”</p></div></div>
                                        ) : (
                                            <div className="h-full overflow-auto custom-scrollbar">
                                                <table className="w-full text-xs border-collapse">
                                                    <thead className="sticky top-0 bg-white shadow-sm z-10">
                                                        <tr>
                                                            <th className="p-2 border bg-gray-100 w-10 text-center">#</th>
                                                            {currentData.gridData[0].map((_, cIdx) => (
                                                                <th key={cIdx} className="p-1 border min-w-[80px]">
                                                                    <select className={`w-full p-1 border rounded text-xs font-bold outline-none ${['length', 'qty'].includes(currentData.colMapping[cIdx]) ? 'bg-blue-100 text-blue-700' : 'bg-gray-50'}`} value={currentData.colMapping[cIdx] || ''} onChange={e => updateCurrentData({ colMapping: {...currentData.colMapping, [cIdx]: e.target.value} })}>
                                                                        <option value="">- ë¬´ì‹œ -</option><option value="thickness">ë‘ê»˜(T)</option><option value="width">ì¥ë³€(W)</option><option value="height">ë‹¨ë³€(H)</option><option value="length">ğŸ“ ê¸¸ì´</option><option value="qty">ğŸ”¢ ìˆ˜ëŸ‰</option><option value="marking">ë§ˆí‚¹</option>
                                                                    </select>
                                                                </th>
                                                            ))}
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {currentData.gridData.slice(0, 50).map((row, rIdx) => (
                                                            <tr key={rIdx} className="hover:bg-blue-50">
                                                                <td className="p-2 border text-center text-gray-400 bg-gray-50">{rIdx + 1}</td>
                                                                {row.map((cell, cIdx) => (
                                                                    <td key={cIdx} className="border p-0 h-8">
                                                                        <input className="excel-input-cell" value={cell} onChange={(e) => handleGridEdit(rIdx, cIdx, e.target.value)} />
                                                                    </td>
                                                                ))}
                                                            </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex-[1] bg-white rounded-xl shadow-sm border border-gray-200 flex flex-col overflow-hidden">
                                        <div className="p-3 bg-blue-800 text-white font-bold text-sm text-center">ê³„ì‚°í•  ê·œê²© ì„ íƒ</div>
                                        <div className="flex-1 p-3 overflow-auto custom-scrollbar space-y-2">
                                            {currentData.availableSpecs.length === 0 ? <div className="text-gray-400 text-center mt-10">1ë‹¨ê³„ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”</div> : currentData.availableSpecs.map(spec => (
                                                <label key={spec} className="flex items-center gap-2 p-2 border rounded hover:bg-gray-50 cursor-pointer">
                                                    <input type="checkbox" className="w-4 h-4 text-blue-600" checked={currentData.selectedSpecs.includes(spec)} onChange={() => toggleSpec(spec)} />
                                                    <span className="font-bold text-gray-700">{spec}</span>
                                                </label>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {viewMode === 'manual' && (
                            <div className="p-6 h-full flex gap-4 overflow-hidden">
                                <div className="flex-1 flex flex-col bg-white rounded-xl shadow border border-gray-200 overflow-hidden">
                                    <div className="p-4 border-b bg-gray-50 flex justify-between items-center">
                                        <div className="flex gap-2">
                                            {Object.keys(currentData.manualRows).length > 0 ? Object.keys(currentData.manualRows).map(spec => (
                                                <button key={spec} onClick={() => updateCurrentData({currentManualSpec: spec})} className={`px-4 py-2 font-bold text-sm rounded ${currentData.currentManualSpec === spec ? 'bg-indigo-600 text-white shadow' : 'bg-gray-200 text-gray-600 hover:bg-gray-300'}`}>{spec}</button>
                                            )) : <span className="text-gray-400 font-bold">ìˆ˜ë™ ì‘ì„± í¸ì§‘ê¸°</span>}
                                        </div>
                                        <div className="flex gap-2">
                                            <button onClick={() => { if(currentData.currentManualSpec) { const newRows = [...currentData.manualRows[currentData.currentManualSpec], getEmptyRow()]; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: newRows}});} }} className="px-4 py-2 border border-dashed border-gray-400 text-gray-600 text-sm font-bold rounded hover:bg-white">+ ë¹ˆ í–‰ ì¶”ê°€</button>
                                            <button onClick={convertManualToResult} className="px-5 py-2 bg-green-600 text-white text-sm font-bold rounded shadow hover:bg-green-700">ìˆ˜ì • ë‚´ìš©ìœ¼ë¡œ ê²°ê³¼ë³´ê¸°</button>
                                        </div>
                                    </div>
                                    <div className="flex-1 overflow-auto custom-scrollbar p-0 relative">
                                        {!currentData.currentManualSpec ? <div className="p-10 text-center text-gray-400">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì²˜ìŒë¶€í„° ì§œê±°ë‚˜ ë³µì‚¬í•´ì˜¤ì„¸ìš”.</div> : (
                                            <table className="w-full text-xs text-center border-collapse bg-white">
                                                <thead className="sticky top-0 bg-white shadow-sm z-10">
                                                    <tr className="bg-gray-100 text-gray-600">
                                                        <th className="border p-2 w-12">ì´ë™</th><th className="border p-2">ë‘ê»˜</th><th className="border p-2">ì¥ë³€</th><th className="border p-2">ë‹¨ë³€</th><th className="border p-2 bg-yellow-100 text-yellow-800">ì›ë³¸ìˆ˜ëŸ‰</th>
                                                        <th className="border p-2 bg-blue-50 text-blue-800">ë‹¨ì²™ê¸¸ì´</th><th className="border p-2 bg-blue-50 text-blue-800">ì»·íŒ…ìˆ˜</th><th className="border p-2 bg-blue-50 text-blue-800">ë§ˆí‚¹</th>
                                                        <th className="border p-2 bg-red-50 text-red-800 w-24">ì‹¤ì‹œê°„ í•©ê³„</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    {currentData.manualRows[currentData.currentManualSpec].map((row, rIdx) => {
                                                        const validCuts = row.cuts.filter(c => c.l && c.count);
                                                        const rowSum = validCuts.reduce((acc, c) => acc + (parseFloat(c.l) * parseInt(c.count)), 0);
                                                        let sumBgColor = 'bg-gray-50 text-gray-500';
                                                        if (rowSum > 5850) sumBgColor = 'bg-red-100 text-red-600 font-bold';
                                                        else if (rowSum > 0 && rowSum < 2000) sumBgColor = 'bg-yellow-100 text-yellow-700 font-bold';
                                                        else if (rowSum >= 2000) sumBgColor = 'bg-green-100 text-green-700 font-bold';
                                                        
                                                        return row.cuts.map((cut, cIdx) => (
                                                            <tr key={`${row.id}-${cIdx}`} draggable={cIdx === 0} onDragStart={(e) => handleDragStart(e, rIdx)} onDragEnter={(e) => handleDragEnter(e, rIdx)} onDragEnd={handleDragEnd} onDragOver={(e) => e.preventDefault()} className="border-b border-gray-200 hover:bg-gray-50 transition-colors">
                                                                {cIdx === 0 && (
                                                                    <>
                                                                        <td rowSpan={8} className="border bg-gray-50">
                                                                            <div className="flex flex-col items-center justify-center gap-2 p-1">
                                                                                <div className="drag-handle p-1" title="ë“œë˜ê·¸í•´ì„œ ìˆœì„œ ì´ë™"><DragIcon /></div>
                                                                                <button onClick={() => { const newRows = currentData.manualRows[currentData.currentManualSpec].filter((_, i) => i !== rIdx); updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: newRows}}); }} className="p-1 text-red-400 hover:text-red-600 hover:bg-red-50 rounded"><Trash2 /></button>
                                                                            </div>
                                                                        </td>
                                                                        <td rowSpan={8} className="border"><input className="input-cell bg-yellow-50" value={row.t} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].t = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                        <td rowSpan={8} className="border"><input className="input-cell bg-yellow-50" value={row.w} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].w = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                        <td rowSpan={8} className="border"><input className="input-cell bg-yellow-50" value={row.h} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].h = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                        <td rowSpan={8} className="border"><input type="number" className="input-cell bg-yellow-50 font-bold text-lg text-yellow-900" value={row.qty} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].qty = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                    </>
                                                                )}
                                                                <td className="border p-0"><input type="number" className="input-cell" value={cut.l} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].cuts[cIdx].l = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                <td className="border p-0"><input type="number" className="input-cell" value={cut.count} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].cuts[cIdx].count = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                <td className="border p-0"><input className="input-cell" value={cut.marking} onChange={e => { const n = [...currentData.manualRows[currentData.currentManualSpec]]; n[rIdx].cuts[cIdx].marking = e.target.value; updateCurrentData({manualRows: {...currentData.manualRows, [currentData.currentManualSpec]: n}}); }} /></td>
                                                                {cIdx === 0 && <td rowSpan={8} className={`border text-base transition-colors ${sumBgColor}`}>{rowSum === 0 ? '-' : rowSum.toLocaleString()}</td>}
                                                            </tr>
                                                        ));
                                                    })}
                                                </tbody>
                                            </table>
                                        )}
                                    </div>
                                </div>
                                <div className="w-[340px] bg-white rounded-xl shadow border flex flex-col overflow-hidden">
                                    <div className="p-3 bg-gray-800 text-white text-sm font-bold text-center">ì‹¤ì‹œê°„ ìì¬ í˜„í™© (ì¶”ì¶œ ë°ì´í„° ê¸°ì¤€)</div>
                                    <div className="flex-1 overflow-auto custom-scrollbar p-0">
                                        <table className="w-full text-xs text-center border-collapse">
                                            <thead className="sticky top-0 bg-white shadow-sm">
                                                <tr className="bg-gray-100 border-b"><th className="p-2">ê·œê²©</th><th className="p-2">ê¸¸ì´</th><th className="p-2">í•„ìš”</th><th className="p-2">ì”ì—¬</th><th className="p-2">ë§ˆí‚¹</th></tr>
                                            </thead>
                                            <tbody>
                                                {remainingSummary.map((item, i) => {
                                                    const remaining = item.required - item.used;
                                                    return (
                                                        <tr key={i} className={`border-b ${remaining === 0 ? 'bg-gray-50 text-gray-400' : 'hover:bg-blue-50'}`}>
                                                            <td className="p-2">{item.width}*{item.height}</td>
                                                            <td className="p-2 font-bold">{item.length}</td>
                                                            <td className="p-2">{item.required}</td>
                                                            <td className={`p-2 font-bold ${remaining < 0 ? 'text-red-500' : (remaining === 0 ? 'text-green-500' : 'text-blue-600')}`}>{remaining}</td>
                                                            <td className="p-2 text-left truncate max-w-[60px]" title={item.marking}>{item.marking}</td>
                                                        </tr>
                                                    );
                                                })}
                                                {remainingSummary.length === 0 && <tr><td colSpan="5" className="p-8 text-gray-400 text-center">1ë²ˆ íƒ­ì—ì„œ ë°ì´í„°ë¥¼ ë¨¼ì € ì½ì–´ì£¼ì„¸ìš”.</td></tr>}
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        )}

                        {viewMode === 'result' && (
                            <div className="p-8 h-full overflow-auto custom-scrollbar bg-white">
                                {!currentData.cpResult ? (
                                    <div className="text-center text-gray-400 mt-20 text-lg">ê³„ì‚°ëœ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>
                                ) : (
                                    <div className="max-w-[1200px] mx-auto pb-20">
                                        <div className="flex justify-end gap-3 mb-6">
                                            <button onClick={copyToManual} className="flex items-center gap-2 bg-indigo-600 text-white px-5 py-2 rounded-lg shadow font-bold hover:bg-indigo-700 transition"><Copy /> ì´ ê²°ê³¼ë¥¼ ë³µì‚¬í•´ì„œ ìˆ˜ë™ìœ¼ë¡œ ììœ ë¡­ê²Œ ìˆ˜ì •í•˜ê¸°</button>
                                            <button onClick={downloadExcel} className="flex items-center gap-2 bg-green-600 text-white px-5 py-2 rounded-lg shadow font-bold hover:bg-green-700 transition"><Download /> ê·œê²©ë³„ ì—‘ì…€ íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œ</button>
                                        </div>
                                        {Object.keys(currentData.cpResult).sort().map((specKey, mapIndex) => {
                                            const patterns = currentData.cpResult[specKey];
                                            if(patterns.length === 0) return null;
                                            
                                            let comp = projectInfo.company || 'ì—…ì²´ëª…'; let site = projectInfo.siteName || 'í˜„ì¥ëª…';
                                            let isDefault = specKey.includes('100*100') && specKey.includes('2.1');
                                            let displayTitle = `${comp}(${site})`;
                                            if (!projectInfo.isNoDong) displayTitle += ` - ${currentDong}`;
                                            if (!isDefault) displayTitle += ` [${specKey}]`;

                                            let warnings = [];
                                            if (projectInfo.isBanding) warnings.push("ì¹ ë°´ë”©ì— ë™í‘œì‹œ í•´ì£¼ì„¸ìš”");
                                            if (projectInfo.isUnder1Ton) warnings.push("1í†¤ ë¯¸ë§Œ ë°´ë”©");
                                            if (projectInfo.memo) warnings.push(projectInfo.memo);

                                            return (
                                                <div key={specKey} className={mapIndex > 0 ? "mt-16 pt-8 border-t-2 border-dashed border-gray-300" : ""}>
                                                    <div className="spec-title">ê·œê²©: {specKey}</div>
                                                    <table className="w-full mb-3 border-none">
                                                        <tbody>
                                                            <tr>
                                                                <td className="text-xl font-bold text-left border-none pb-2">{displayTitle}</td>
                                                                <td className="text-sm text-right border-none pb-2">ë‚ ì§œ: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ë‹´ë‹¹ì: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    {warnings.length > 0 && <div className="text-red-600 font-bold text-lg mb-2">{warnings.join(', ')}</div>}
                                                    <table className="excel-table">
                                                        <thead>
                                                            <tr>
                                                                <th style={{width:'4%'}}>ìˆœë²ˆ</th><th style={{width:'6%'}}>ë‘ê»˜</th><th style={{width:'6%'}}>ì¥ë³€</th><th style={{width:'6%'}}>ë‹¨ë³€</th><th style={{width:'8%'}}>ì„ íƒ€ê³µê¸¸ì´</th><th style={{width:'5%'}}>ìˆ˜ëŸ‰</th><th style={{width:'10%'}}>ë‹¨ì²™ê¸¸ì´</th><th style={{width:'8%'}}>ì»·íŒ… ìˆ˜</th><th style={{width:'6%'}}>ìˆ˜ëŸ‰</th><th style={{width:'15%'}}>ë§ˆí‚¹</th><th style={{width:'8%'}}>í•©ê³„</th><th style={{width:'8%'}}>ë¡œìŠ¤</th><th style={{width:'6%'}}>ì»·íŒ…ë‚ </th><th style={{width:'4%'}}>ë¹„ê³ </th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {patterns.map((pattern, index) => {
                                                                let piecesCount = pattern.groups.length;
                                                                let totalCuts = pattern.groups.reduce((sum, g) => sum + g.cutCount, 0);
                                                                let bladeLoss = (totalCuts * 2.6).toFixed(1).replace('.0', '');
                                                                let displayLoss = `- ${pattern.totalLength.toLocaleString()}`; 
                                                                
                                                                return pattern.groups.map((group, pIdx) => (
                                                                    <tr key={`${index}-${pIdx}`}>
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{index + 1}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{pattern.thick.toFixed(2)}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{pattern.width}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{pattern.height}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}></td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{pattern.count}</td>}
                                                                        <td style={{borderBottom: pIdx === piecesCount - 1 ? '1px solid #000' : '1px dashed #999'}}>{group.length}</td>
                                                                        <td style={{borderBottom: pIdx === piecesCount - 1 ? '1px solid #000' : '1px dashed #999'}}>{group.cutCount}</td>
                                                                        <td style={{borderBottom: pIdx === piecesCount - 1 ? '1px solid #000' : '1px dashed #999'}}>{group.cutCount * pattern.count}</td>
                                                                        <td style={{borderBottom: pIdx === piecesCount - 1 ? '1px solid #000' : '1px dashed #999', textAlign: 'left', paddingLeft: '8px'}}>{group.marking}</td>
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{pattern.totalLength.toLocaleString()}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{displayLoss}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}>{bladeLoss}</td>}
                                                                        {pIdx === 0 && <td rowSpan={piecesCount}></td>}
                                                                    </tr>
                                                                ));
                                                            })}
                                                            <tr style={{backgroundColor: '#fff2cc', fontWeight: 'bold'}}>
                                                                <td colSpan="5">í•© ê³„</td>
                                                                <td>{patterns.reduce((sum, p) => sum + p.count, 0)}</td>
                                                                <td colSpan="2">í•© ê³„</td>
                                                                <td>{patterns.reduce((sum, p) => sum + p.groups.reduce((s, c) => s + (c.cutCount * p.count), 0), 0)}</td>
                                                                <td colSpan="5"></td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>